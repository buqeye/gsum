
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>buqeyemodel.models &#8212; buqeyemodel 0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">buqeyemodel 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar"><a href="
    ../../index.html" class="text-logo">buqeyemodel</a>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

    
  </div>
</div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../index.html">Module code</a></li>
              
              <li>buqeyemodel.models</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <h1>Source code for buqeyemodel.models</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">pymc3</span> <span class="k">as</span> <span class="nn">pm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">theano</span>
<span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">tt</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pymc3.math</span> <span class="k">import</span> <span class="n">cartesian</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integrate</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">.helpers</span> <span class="k">import</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">gaussian</span><span class="p">,</span> <span class="n">stabilize</span>
<span class="kn">from</span> <span class="nn">statsmodels.sandbox.distributions.mv_normal</span> <span class="k">import</span> <span class="n">MVT</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SGP&#39;</span><span class="p">,</span> <span class="s1">&#39;PowerProcess&#39;</span><span class="p">,</span> <span class="s1">&#39;PowerSeries&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="SGP"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP">[docs]</a><span class="k">class</span> <span class="nc">SGP</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">R</span><span class="sd">&quot;&quot;&quot;A semiparametric Gaussian process class</span>

<span class="sd">    Treats a function :math:`y` as a Gaussian process</span>

<span class="sd">    .. math::</span>

<span class="sd">        y(x) | \beta, \sigma^2, \psi \sim N[m(x), \sigma^2 R(x,x; \psi)]</span>

<span class="sd">    with a parameterized mean function :math:`m` and correlation function</span>
<span class="sd">    :math:`R`. The mean at any input point is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        m(x) = h(x)^T \beta</span>

<span class="sd">    where :math:`h: \mathbb{R}^d \to \mathbb{R}^q` is a given basis function</span>
<span class="sd">    and :math:`\beta` is a :math:`q\times 1` vector of random variables.</span>
<span class="sd">    The variance is split into a marginal part :math:`\sigma^2` and a</span>
<span class="sd">    correlation function :math:`R` that may further depend on parameters</span>
<span class="sd">    :math:`\psi`, e.g., length scales.</span>
<span class="sd">    A normal-inverse-gamma prior is placed on :math:`\beta` and</span>
<span class="sd">    :math:`\sigma^2`</span>

<span class="sd">    .. math::</span>

<span class="sd">        \beta, \sigma^2 \sim NIG(\mu, V, a, b)</span>

<span class="sd">    The means and covariance of the normal prior placed on :math:`\beta` are</span>
<span class="sd">    :math:`\mu` and :math:`\sigma^2 V`, while the shape and scale parameter of</span>
<span class="sd">    the inverse gamma prior placed on :math:`\sigma^2` are :math:`a` and</span>
<span class="sd">    :math:`b`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : scalar, optional</span>
<span class="sd">        The dimension of the ``means`` vector and the ``cov`` matrix, which</span>
<span class="sd">        determines how many mean variables are undetermined in the linear</span>
<span class="sd">        model. Must be greater than 0. By default, ``dim`` is inferred by</span>
<span class="sd">        the columns of the ``basis`` callable.</span>
<span class="sd">    basis : callable, optional</span>
<span class="sd">        The basis function for the mean vector.</span>
<span class="sd">    means : (dim,) array, optional</span>
<span class="sd">    cov : (dim,dim) array, optional</span>
<span class="sd">    shape : scalar, optional</span>
<span class="sd">    scale : scalar, optional</span>
<span class="sd">    corr : callable, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">gaussian</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">corr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;corr must be callable&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span>

        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;basis must be non-zero scalar or callable&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_function</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># if not callable(basis):</span>
        <span class="c1">#     raise ValueError(&#39;basis must be callable&#39;)</span>
        <span class="c1"># self.basis = basis</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dim must be greater than or equal to one&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">means</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;means length does not match dim&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">means</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;means must be 1d array or scalar&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">means_0</span> <span class="o">=</span> <span class="n">means</span>
        <span class="c1"># self.mean_dim = len(self.means_0)</span>

        <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape of cov must be (dim, dim)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">=</span> <span class="n">scale</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="n">cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span>

    <span class="k">def</span> <span class="nf">_domain_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">isNumber</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">*</span><span class="n">obj</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">isNumber</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">elif</span> <span class="n">isNumber</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dom_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">cols</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">obj</span> <span class="o">*</span> <span class="n">vec</span>
            <span class="k">return</span> <span class="n">dom_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> must be a number or function&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<div class="viewcode-block" id="SGP.observe"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.observe">[docs]</a>    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Observe GP outputs and update parameters.</span>

<span class="sd">        Conditions on :math:`n` iid processes at :math:`N` locations</span>
<span class="sd">        :math:`X`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : (N,d) array</span>
<span class="sd">            The input locations where the GPs are observed. :math:`N` is the</span>
<span class="sd">            number of points observed along each process, and :math:`d` is the</span>
<span class="sd">            dimensionality of each input point. If the process is a 1d curve,</span>
<span class="sd">            then ``X`` must be an ``(N, 1)`` shaped vector.</span>
<span class="sd">        y : (n, N) array</span>
<span class="sd">            The :math:`N` observed values of each of the :math:`n` iid</span>
<span class="sd">            processes. If only one process has been observed, this must have</span>
<span class="sd">            shape ``(1, N)``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            The keyword arguments passed to the correlation function. These</span>
<span class="sd">            values will be saved and used as defaults for all other methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X and y must be 2d arrays&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X row length must match y column length&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_kwargs</span> <span class="o">=</span> <span class="n">corr_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">stabilize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_recompute_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="c1"># Must be non-empty and not equal to the defaults</span>
        <span class="k">return</span> <span class="n">corr_kwargs</span> <span class="ow">and</span> <span class="n">corr_kwargs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_kwargs</span>

<div class="viewcode-block" id="SGP.shape"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.shape">[docs]</a>    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The shape parameter :math:`a` of the inverse gamma distribution</span>

<span class="sd">        If ``y`` is given or ``observe`` has been used, then the posterior</span>
<span class="sd">        value is returned, else, the prior value is returned. The prior</span>
<span class="sd">        value can also be accessed with the ``shape_0`` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            The data on which to condition. Defaults to ``None``, which uses</span>
<span class="sd">            the data supplied by ``observe`` and returns a cached value.</span>
<span class="sd">            If observe has not been called, this returns the prior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            The shape parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>
        <span class="n">num_y</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">+</span> <span class="n">N</span> <span class="o">*</span> <span class="n">num_y</span> <span class="o">/</span> <span class="mf">2.0</span></div>

<div class="viewcode-block" id="SGP.scale"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The scale parameter :math:`b` of the inverse gamma distribution</span>

<span class="sd">        If ``y`` is given or ``observe`` has been used,</span>
<span class="sd">        then the posterior value is returned, else, the prior value is</span>
<span class="sd">        returned. The prior value can also be accessed with the ``scale_0``</span>
<span class="sd">        attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            The data on which to condition. Defaults to ``None``, which uses</span>
<span class="sd">            the data supplied by ``observe``.</span>
<span class="sd">            If observe has not been called, this returns the prior.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            The keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to the valued supplied to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            The scale parameter. If ``y is None`` and ``corr_kwargs`` are</span>
<span class="sd">            omitted or the same as those passed to ``observe``, a cached</span>
<span class="sd">            value is returned, else it is recomputed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

        <span class="c1"># Set up variables</span>
        <span class="n">means_0</span><span class="p">,</span> <span class="n">inv_cov_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span>
        <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">R_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="c1"># Compute quadratics</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">means_0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_cov_0</span><span class="p">,</span> <span class="n">means_0</span><span class="p">))</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">-</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">means</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">+</span> <span class="n">val</span> <span class="o">/</span> <span class="mf">2.0</span></div>

<div class="viewcode-block" id="SGP.means"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.means">[docs]</a>    <span class="k">def</span> <span class="nf">means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The mean parameters :math:`\mu` of the normal distribution on :math:`\beta`</span>

<span class="sd">        If ``y`` is given or ``observe`` has been used,</span>
<span class="sd">        then the posterior value is returned, else, the prior value is</span>
<span class="sd">        returned. The prior value can also be accessed with the ``means_0``</span>
<span class="sd">        attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            The data on which to condition. Defaults to ``None``, which uses</span>
<span class="sd">            the data supplied by ``observe``.</span>
<span class="sd">            If observe has not been called, this returns the prior.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            The keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to the valued supplied to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (dim,) array</span>
<span class="sd">            The means of :math:`\beta`. If ``y is None`` and ``corr_kwargs``</span>
<span class="sd">            are omitted or the same as those passed to ``observe``, a cached</span>
<span class="sd">            value is returned, else it is recomputed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_means</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">num_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">avg_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">Rinv_y</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">avg_y</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means_0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">num_y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Rinv_y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGP.inv_cov"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.inv_cov">[docs]</a>    <span class="k">def</span> <span class="nf">inv_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The inverse covariance :math:`V^{-1}` of the normal distribution on</span>
<span class="sd">        :math:`\beta`</span>

<span class="sd">        If ``y`` is given or ``observe`` has been used,</span>
<span class="sd">        then the posterior value is returned, else, the prior value is</span>
<span class="sd">        returned. The prior value can also be accessed with the ``inv_cov_0``</span>
<span class="sd">        attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            The data on which to condition. Defaults to ``None``, which uses</span>
<span class="sd">            the data supplied by ``observe``.</span>
<span class="sd">            If observe has not been called, this returns the prior.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            The keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to the valued supplied to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (dim,) array</span>
<span class="sd">            The inverse covariance of :math:`\beta`. If ``y is None`` and</span>
<span class="sd">            ``corr_kwargs`` are omitted or the same as those passed to</span>
<span class="sd">            ``observe``, a cached value is returned, else it is recomputed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_cov</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">num_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># num_y = num_y if num_y is not None else self.num_y</span>
        <span class="n">R_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>

        <span class="n">right</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">R_chol</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span> <span class="o">+</span> <span class="n">num_y</span> <span class="o">*</span> <span class="n">quad</span></div>

<div class="viewcode-block" id="SGP.cov"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.cov">[docs]</a>    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The covariance :math:`V` of the normal distribution on :math:`\beta`</span>

<span class="sd">        If ``y`` is given or ``observe`` has been used,</span>
<span class="sd">        then the posterior value is returned, else, the prior value is</span>
<span class="sd">        returned. The prior value can also be accessed with the ``cov_0``</span>
<span class="sd">        attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            The data on which to condition. Defaults to ``None``, which uses</span>
<span class="sd">            the data supplied by ``observe``.</span>
<span class="sd">            If observe has not been called, this returns the prior.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            The keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to the valued supplied to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (dim,) array</span>
<span class="sd">            The covariance of :math:`\beta`. If ``y is None`` and</span>
<span class="sd">            ``corr_kwargs`` are omitted or the same as those passed to</span>
<span class="sd">            ``observe``, a cached value is returned, else it is recomputed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">chol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">stabilize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chol</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span>

<div class="viewcode-block" id="SGP.student_params"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.student_params">[docs]</a>    <span class="k">def</span> <span class="nf">student_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Returns the parameters of the student :math:`t` distribution.</span>

<span class="sd">        Given a function</span>

<span class="sd">        .. math::</span>

<span class="sd">            y | \beta, \sigma^2, \psi \sim N[H\beta, \sigma^2 R]</span>

<span class="sd">        with a normal inverse gamma prior on :math:`\beta, \sigma^2`,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \beta, \sigma^2 \sim NIG(\mu, V, a, b)</span>

<span class="sd">        the integrated process is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            y | \psi \sim MVT\left[2a, H\mu, \frac{b}{a} (R + HVH^T)\right]</span>

<span class="sd">        If data has been observed, then posterior values for :math:`\mu,V,a,b`</span>
<span class="sd">        are used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : (N, d) array, optional</span>
<span class="sd">            The input points at which to compute the basis ``H`` and ``R``.</span>
<span class="sd">            If ``None``, then the defaults from the ``observe`` method are</span>
<span class="sd">            used.</span>
<span class="sd">        H : (N, q) array, optional</span>
<span class="sd">            The basis function evaluated at :math:`N` points. If None, then</span>
<span class="sd">            the basis function is computed at ``X``.</span>
<span class="sd">        R : (N, N) array, optional</span>
<span class="sd">            The correlation matrix. If None, then the correlation function is</span>
<span class="sd">            computed using ``X`` and **corr_kwargs.</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            Observed GP values used to compute the updated normal-inverse-gamma</span>
<span class="sd">            hyperparameters. If ``None``, then the data passed to the</span>
<span class="sd">            ``observe`` method are used. If ``observe`` has not been called,</span>
<span class="sd">            prior values are used.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Optional keyword arguments for the correlation function. If none</span>
<span class="sd">            are provided, defaults from the ``observe`` method are used</span>
<span class="sd">            instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The degrees of freedom, mean, and sigma matrix of a multivariate</span>
<span class="sd">            :math:`t` distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="n">corr_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_kwargs</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
        <span class="k">if</span> <span class="n">H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">means</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">/</span> <span class="n">shape</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shape</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span></div>

    <span class="k">def</span> <span class="nf">_build_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="c1"># Set up variables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="n">corr_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_kwargs</span>

        <span class="k">if</span> <span class="n">corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span>
            <span class="n">R_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
            <span class="n">R_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">stabilize</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="n">R_12</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Xp</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">R_21</span> <span class="o">=</span> <span class="n">R_12</span><span class="o">.</span><span class="n">T</span>
        <span class="n">R_22</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">Xp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">H_2</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>

        <span class="c1"># Compute conditional covariance</span>
        <span class="n">Rinv_R12</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">R_12</span><span class="p">)</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_21</span><span class="p">,</span> <span class="n">Rinv_R12</span><span class="p">)</span>
        <span class="n">R_new</span> <span class="o">=</span> <span class="n">R_22</span> <span class="o">-</span> <span class="n">quad</span>

        <span class="c1"># Conditional basis</span>
        <span class="n">Rinv_H</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">H_new</span> <span class="o">=</span> <span class="n">H_2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_21</span><span class="p">,</span> <span class="n">Rinv_H</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Rinv_yn</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Rinv_yn</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">R_chol</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="n">index</span><span class="p">])</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_21</span><span class="p">,</span> <span class="n">Rinv_yn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span>

<div class="viewcode-block" id="SGP.conditional"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.conditional">[docs]</a>    <span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Returns a conditional distribution object anchored to observed points.</span>

<span class="sd">        The conditional Gaussian process given the observed ``y[index]`` is</span>
<span class="sd">        marginalized over :math:`\beta` and :math:`\sigma^2`. The resulting</span>
<span class="sd">        distribution is a multivariate student :math:`t` distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the observed ``y`` to condition upon. Despite only</span>
<span class="sd">            one process being interpolated at a time, the hyperparameters</span>
<span class="sd">            are still updated by all curves at once.</span>
<span class="sd">        Xnew : (M, d) array</span>
<span class="sd">            The :math:`M` new input points at which to predict the value of the</span>
<span class="sd">            process.</span>
<span class="sd">        corr : bool, optional</span>
<span class="sd">            Whether or not the distribution object is correlated. For</span>
<span class="sd">            visualizing the mean and marginal variance, an uncorrelated</span>
<span class="sd">            conditional often suffices. Defaults to ``False``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Optional keyword arguments for the correlation function. If none</span>
<span class="sd">            are provided, defaults from the ``observe`` method are used</span>
<span class="sd">            instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distribution object</span>
<span class="sd">            If ``corr is False`` then a ``scipy.stats.t`` distribution is</span>
<span class="sd">            returned, else a</span>
<span class="sd">            ``statsmodels.sandbox.distributions.mv_normal.MVT`` is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
            <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">student_params</span><span class="p">(</span>
            <span class="n">H</span><span class="o">=</span><span class="n">H_new</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R_new</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">+=</span> <span class="n">shift</span>
        <span class="k">if</span> <span class="n">corr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MVT</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGP.condition"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.condition">[docs]</a>    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Conditions on observed data and returns interpolant and error bands.</span>

<span class="sd">        Extracts the mean and degree of belief intervals from the corresponding</span>
<span class="sd">        conditional object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the observed ``y`` to condition upon. Despite only</span>
<span class="sd">            one process being interpolated at a time, the hyperparameters</span>
<span class="sd">            are still updated by all curves at once.</span>
<span class="sd">        Xnew : (M, d) array</span>
<span class="sd">            The :math:`M` new input points at which to predict the value of the</span>
<span class="sd">            process.</span>
<span class="sd">        dob : scalar or 1d array, optional</span>
<span class="sd">            The degree of belief intervals to compute, between 0 and 1.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Optional keyword arguments for the correlation function. If none</span>
<span class="sd">            are provided, defaults from the ``observe`` method are used</span>
<span class="sd">            instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array or tuple</span>
<span class="sd">            If ``dob is None``, then only the 1D array of predictions is</span>
<span class="sd">            returned. Otherwise, the predictions along with a</span>
<span class="sd">            :math:`2 \times N` (or :math:`len(dob) \times 2 \times N`) of</span>
<span class="sd">            degree of belief intervals is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="n">dob</span><span class="p">)</span></div>

<div class="viewcode-block" id="SGP.predictive"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.predictive">[docs]</a>    <span class="k">def</span> <span class="nf">predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a posterior predictive distribution object.</span>

<span class="sd">        Predicts new curves given the observed curves ``y``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xnew : (M, d) array</span>
<span class="sd">            The :math:`M` new input points at which to predict the value of the</span>
<span class="sd">            process.</span>
<span class="sd">        corr : bool, optional</span>
<span class="sd">            Whether or not the distribution object is correlated. For</span>
<span class="sd">            visualizing the mean and marginal variance, an uncorrelated</span>
<span class="sd">            conditional often suffices. Defaults to ``False``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Optional keyword arguments for the correlation function. If none</span>
<span class="sd">            are provided, defaults from the ``observe`` method are used</span>
<span class="sd">            instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distribution object</span>
<span class="sd">            If ``corr is False`` then a ``scipy.stats.t`` distribution is</span>
<span class="sd">            returned, else a</span>
<span class="sd">            ``statsmodels.sandbox.distributions.mv_normal.MVT`` is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">student_params</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MVT</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictive</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="n">dob</span><span class="p">)</span>

<div class="viewcode-block" id="SGP.evidence"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.evidence">[docs]</a>    <span class="k">def</span> <span class="nf">evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Computes the evidence, or marginal likelihood, of the observed data</span>

<span class="sd">        Specifically, the evidence integrates out :math:`\beta` and</span>
<span class="sd">        :math:`\sigma^2` such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr(y | \psi) = \frac{\Gamma(a)}{\Gamma(a_0)} \frac{b_0^{a_0}}{b^a}</span>
<span class="sd">                \sqrt{\frac{|V|}{|V_0|}} [(2\pi)^N |R|]^{-n/2}</span>

<span class="sd">        where subscript 0&#39;s denote prior values. If the priors on :math:`a_0`</span>
<span class="sd">        or :math:`V_0` are uninformative, then the evidence is undefined, but</span>
<span class="sd">        in this case the evidence is approximated by</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr(y | \psi) = \frac{\Gamma(a) \sqrt{|V|}}{b^a}</span>
<span class="sd">                [(2\pi)^N |R|]^{-n/2}</span>

<span class="sd">        This is appropriate for model comparison since the factor due to priors</span>
<span class="sd">        is only a constant and hence cancels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log : bool, optional</span>
<span class="sd">            Whether to return the log of the evidence, which can be useful</span>
<span class="sd">            for numerical reasons.</span>
<span class="sd">        y : (n, N) array, optional</span>
<span class="sd">            Data for which to compute the evidence. Defaults to the data</span>
<span class="sd">            passed to the ``observe`` method.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to those passed to the ``observe`` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            The (log) evidence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">R_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">num_y</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">tr_log_R</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">R_chol</span><span class="p">)))</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">logdet_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>

        <span class="n">ev</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">num_y</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="n">tr_log_R</span><span class="p">)</span>
        <span class="n">ev</span> <span class="o">+=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">logdet_cov</span> <span class="o">-</span> \
            <span class="n">shape</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If non-zero</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">logdet_inv_cov_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov_0</span><span class="p">)</span>
            <span class="n">ev</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span><span class="p">)</span> <span class="o">+</span> \
                <span class="mf">0.5</span> <span class="o">*</span> <span class="n">logdet_inv_cov_0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ev</span></div>

<div class="viewcode-block" id="SGP.posterior"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.posterior">[docs]</a>    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">logprior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the posterior pdf for arbitrary correlation variables</span>

<span class="sd">        Uses Bayes&#39; Theorem to compute</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr(\ell | y, ...) \propto pr(y | \ell, ...) pr(\ell)</span>

<span class="sd">        for any correlation parameter :math:`\ell`. The evidence given</span>
<span class="sd">        :math:`\ell` and the other correlation parameters (...) is then</span>
<span class="sd">        used to compute the posterior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the variable passed to the correlation function</span>
<span class="sd">            for which to calculate the poster</span>
<span class="sd">        logprior : callable, optional</span>
<span class="sd">            The log prior to place on ``name``. Must accept ``**corr_kwargs``</span>
<span class="sd">            as arguments. Defaults to ``None``, which sets ``logprior`` to zero</span>
<span class="sd">        log : bool, optional</span>
<span class="sd">            Whether to return the log posterior. If ``False``, then the pdf</span>
<span class="sd">            will be approximately normalized using the trapezoid rule. Defaults</span>
<span class="sd">            to ``False``</span>
<span class="sd">        **corr_kwargs :</span>
<span class="sd">            Keyword arguments passed to the correlation function. One of the</span>
<span class="sd">            arguments must match ``name`` and must be an array. Nothing will</span>
<span class="sd">            be inferred from the ``observe`` call here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The (log) posterior pdf for the ``name`` variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">val</span><span class="p">)}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evidence</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">log_pdf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">logprior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">logprior</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">corr_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="c1"># Integrate using trapezoid rule</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pdf</span><span class="o">/</span><span class="n">norm</span>
        <span class="k">return</span> <span class="n">log_pdf</span></div>

<div class="viewcode-block" id="SGP.corr_post"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.SGP.corr_post">[docs]</a>    <span class="k">def</span> <span class="nf">corr_post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logprior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the posterior for the correlation parameters in corr_kwargs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logprior : callable</span>
<span class="sd">        corr_kwargs : dict</span>
<span class="sd">            The values of the correlation parameters at which to evaluate the</span>
<span class="sd">            posterior. Because the evidence is vectorized, standard</span>
<span class="sd">            array broadcasting rules apply</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not callable(logprior):</span>
        <span class="c1">#     raise ValueError(&#39;logprior must be callable&#39;)</span>

        <span class="n">vec_evidence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evidence</span><span class="p">)</span>
        <span class="n">log_post</span> <span class="o">=</span> <span class="n">vec_evidence</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logprior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_post</span> <span class="o">=</span> <span class="n">log_post</span> <span class="o">+</span> <span class="n">logprior</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">log_post</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_post</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_post</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PowerProcess"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess">[docs]</a><span class="k">class</span> <span class="nc">PowerProcess</span><span class="p">(</span><span class="n">SGP</span><span class="p">):</span>
    <span class="sa">R</span><span class="sd">&quot;&quot;&quot;A power series with iid random processes as coefficients.</span>

<span class="sd">    Implements the following model</span>

<span class="sd">    .. math::</span>

<span class="sd">        S_k(x) = S_{\mathrm{ref}}(x) \sum_{n=0}^k c_n(x) r(x)^n</span>

<span class="sd">    where the :math:`c_n` are Gaussian processes with parameters using</span>
<span class="sd">    conjugate priors</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_n(x) | \beta, \sigma^2, \psi &amp; \sim N(m(x), \sigma^2 R(x,x;\psi)) \\</span>
<span class="sd">        \beta, \sigma^2 &amp; \sim NIG(\mu, V, a, b)</span>

<span class="sd">    Conditioning on partial sums :math:`S_{0}`, :math:`\dots,` :math:`S_k`,</span>
<span class="sd">    allow one to estimate the full summation and obtain posteriors for the</span>
<span class="sd">    parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_recompute_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">and</span> <span class="n">ratio_kwargs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;recomputing...&#39;</span><span class="p">)</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">(</span>
                <span class="n">partials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">),</span> <span class="n">orders</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span><span class="p">,</span>
                <span class="c1"># rm_orders=self.rm_orders,</span>
                <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="PowerProcess.observe"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.observe">[docs]</a>    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">leading_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Observe the partial sums of the series and update parameters.</span>

<span class="sd">        The partial sums are observed at the input locations ``X``.</span>
<span class="sd">        Using the given ``ratio`` and ``ref``, the coefficients of the series</span>
<span class="sd">        are extracted and are used to create posterior distributions for the</span>
<span class="sd">        mean and variance parameters. One can then interpolate partial sums or</span>
<span class="sd">        predict the value of the full summation at new points. Additional</span>
<span class="sd">        functionality, including evidence calculations and posteriors for the</span>
<span class="sd">        ratio and correlation functions are possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : (N,d) array</span>
<span class="sd">            The :math`N` input locations where the partial sums are observed.</span>
<span class="sd">            Columns correspond to the dimensionality of the input space. If 1D,</span>
<span class="sd">            ``X`` must be an :math:`N \times 1` column vector.</span>
<span class="sd">        partials : (n,N) array</span>
<span class="sd">            The :math:`n` lowest known partial sums, each with :math:`N` points</span>
<span class="sd">            observed along each curve.</span>
<span class="sd">        ratio : callable, scalar, or (N,) array</span>
<span class="sd">            The value of the ratio that scales each order in the power</span>
<span class="sd">            series with increasing powers. If callable, it must accept ``X``</span>
<span class="sd">            as its first argument and can optionally accept **ratio_kwargs.</span>
<span class="sd">        ref : callable, scalar, or length (N,) array</span>
<span class="sd">            The overall scale of the power series. If callable, it must</span>
<span class="sd">            accept ``X`` as its first argument. The default value is 1.</span>
<span class="sd">        orders : (n,) array</span>
<span class="sd">            The orders of the given partial sums. If ``None``, it is assumed</span>
<span class="sd">            that all orders from 0 to math:`n` are given: ``[0, 1, ..., n]``.</span>
<span class="sd">        leading_kwargs : dict</span>
<span class="sd">            Keyword arguments passed to an ``SGP`` initializer for the leading</span>
<span class="sd">            order coefficient. This allows the leading order to be treated</span>
<span class="sd">            differently than the other orders of the series. ``corr_kwargs``</span>
<span class="sd">            can also be in this dict and will be passed to the ``observe``</span>
<span class="sd">            method of the leading order ``SGP``. Defaults to ``None``, in which</span>
<span class="sd">            case the leading order is an iid coefficient like the others.</span>
<span class="sd">        ratio_kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the correlation function.</span>
<span class="sd">            These values will be saved and used as defaults for all other</span>
<span class="sd">            methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if corr_kwargs is None:</span>
        <span class="c1">#     corr_kwargs = {}</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span> <span class="o">=</span> <span class="n">ratio_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orders</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partials</span> <span class="o">=</span> <span class="n">partials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_function</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_function</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">(</span>
            <span class="n">partials</span><span class="o">=</span><span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">orders</span><span class="o">=</span><span class="n">orders</span><span class="p">,</span>
            <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orders</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leading_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">leading_corr_kwargs</span> <span class="o">=</span> <span class="n">leading_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;corr_kwargs&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_leading_corr_kwargs</span> <span class="o">=</span> <span class="n">leading_corr_kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leading_process</span> <span class="o">=</span> <span class="n">SGP</span><span class="p">(</span><span class="o">**</span><span class="n">leading_kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leading_process</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                         <span class="o">**</span><span class="n">leading_corr_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orders</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordersvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Get max order</span>
        <span class="n">max_order_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">max_order_arg</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_partial</span> <span class="o">=</span> <span class="n">partials</span><span class="p">[</span><span class="n">max_order_arg</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PowerProcess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">coeffs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">],</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="c1"># Set up variables</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_corr</span><span class="p">(</span><span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
            <span class="n">corr_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_kwargs</span>
        <span class="n">all_ords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;leading_process&#39;</span><span class="p">):</span>
            <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leading_process</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
                <span class="c1"># print(self.ref(Xnew).shape)</span>
                <span class="n">H_new</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">shift</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
                <span class="n">R_new</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span>
        <span class="k">elif</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="n">low_ords</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orders</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">all_ords</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>

            <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">ratio_sum</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">low_ords</span><span class="p">:</span>
                    <span class="n">ratio_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">ratio</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">low_ords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">X</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">ratio_sum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Xp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Xp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Xp</span> <span class="o">=</span> <span class="n">X</span>
                <span class="n">ratioX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
                <span class="n">ratioXp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">Xp</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
                <span class="c1"># ratio_mat = 1</span>
                <span class="k">if</span> <span class="n">low_ords</span><span class="p">:</span>
                    <span class="n">ratio_mat</span> <span class="o">=</span> <span class="n">ratioX</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratioXp</span>
                    <span class="n">ratio_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">ratio_mat</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">low_ords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">ref_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">X</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xp</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ref_mat</span> <span class="o">*</span> <span class="n">ratio_mat</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Xp</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partials</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;leading_process&#39;</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PowerProcess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">corr</span><span class="o">=</span><span class="n">corr</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
            <span class="c1"># if hasattr(self, &#39;leading_process&#39;):</span>
            <span class="c1">#     shift += self.ref(Xnew) * shift_0</span>
            <span class="c1"># H_new, shift, R_new = super(PowerProcess, self)._build_conditional(</span>
            <span class="c1">#     Xnew=Xnew, index=index, y=self.partials, basis=basis,</span>
            <span class="c1">#     corr=corr, **corr_kwargs)</span>
            <span class="c1"># shift += self.ref(Xnew)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">(</span>
                <span class="n">partials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">),</span> <span class="n">orders</span><span class="o">=</span><span class="n">all_ords</span><span class="p">,</span>
                <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
            <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PowerProcess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span>

    <span class="k">def</span> <span class="nf">_integrated_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="n">H_new</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">R_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
            <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
            <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># For predictive</span>
            <span class="n">H_pred</span><span class="p">,</span> <span class="n">R_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_predictive</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="n">max_order</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
            <span class="n">H_new</span> <span class="o">+=</span> <span class="n">H_pred</span>
            <span class="n">R_new</span> <span class="o">+=</span> <span class="n">R_pred</span>

        <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">student_params</span><span class="p">(</span>
            <span class="n">H</span><span class="o">=</span><span class="n">H_new</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R_new</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">+=</span> <span class="n">shift</span>

        <span class="k">if</span> <span class="n">rescale</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;leading_process&#39;</span><span class="p">):</span>
            <span class="c1"># Must include leading term here</span>
            <span class="n">H_0</span><span class="p">,</span> <span class="n">shift_0</span><span class="p">,</span> <span class="n">R_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_conditional</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
            <span class="c1"># H_0_scaled = self.ref(Xnew) * H_0</span>
            <span class="n">df_0</span><span class="p">,</span> <span class="n">mean_0</span><span class="p">,</span> <span class="n">sigma_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">student_params</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H_0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R_0</span><span class="p">)</span>
            <span class="n">mean</span> <span class="o">+=</span> <span class="n">mean_0</span> <span class="o">+</span> <span class="n">shift_0</span>
            <span class="n">sigma</span> <span class="o">+=</span> <span class="n">sigma_0</span>
            <span class="n">df</span> <span class="o">+=</span> <span class="n">df_0</span>

        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span>

<div class="viewcode-block" id="PowerProcess.conditional"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.conditional">[docs]</a>    <span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Returns a conditional distribution object anchored to observed points.</span>

<span class="sd">        The conditional distribution of the coefficients, or partial sums, is</span>
<span class="sd">        marginalized over the means and variance parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xnew : (M,d) array</span>
<span class="sd">            The new input points at which to predict the values of the</span>
<span class="sd">            coefficients or partial sums.</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the partial sum to interpolate.</span>
<span class="sd">        corr : bool, optional</span>
<span class="sd">            Whether or not the conditional distribution is correlated in the</span>
<span class="sd">            input space. For visualizing the mean and marginal variance, an</span>
<span class="sd">            uncorrelated conditional often suffices. Defaults to ``False``.</span>
<span class="sd">        rescale : bool, optional</span>
<span class="sd">            Whether or not to rescale the coefficient back to a partial sum.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``, which uses the values passed to ``observe``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the correlation function.</span>
<span class="sd">            Defaults to the keywords passed to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distribution object</span>
<span class="sd">            If ``corr is False`` then a ``scipy.stats.t`` distribution is</span>
<span class="sd">            returned, else a</span>
<span class="sd">            ``statsmodels.sandbox.distributions.mv_normal.MVT`` is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrated_conditional</span><span class="p">(</span>
            <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">corr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MVT</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerProcess.condition"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.condition">[docs]</a>    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Conditions on observed data and returns interpolant and error bands.</span>

<span class="sd">        Extracts the mean and degree of belief intervals from the corresponding</span>
<span class="sd">        conditional object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xnew : 2D array</span>
<span class="sd">            The new input points at which to predict the values of the</span>
<span class="sd">            coefficients or partial sums.</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the partial sum to interpolate.</span>
<span class="sd">        dob : scalar or 1D array, optional</span>
<span class="sd">            The degree of belief intervals to compute, between 0 and 1.</span>
<span class="sd">        rescale : bool, optional</span>
<span class="sd">            Whether or not to rescale the coefficient back to a partial sum.</span>
<span class="sd">            Defaults to ``True``</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``, which uses the values passed to ``observe``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the correlation function.</span>
<span class="sd">            Defaults to the keywords passed to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1D array or tuple</span>
<span class="sd">            If ``dob is None``, then only the 1D array of predictions is</span>
<span class="sd">            returned. Otherwise, the predictions along with a</span>
<span class="sd">            :math:`2 \times N` (or :math:`len(dob) \times 2 \times N`) of</span>
<span class="sd">            degree of belief intervals is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
                                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="n">dob</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="k">if</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># Largest observed order</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Find geometric sum of ratio from k to max_order</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">r_mat</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mu_sum</span> <span class="o">=</span> <span class="n">r</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="p">(</span><span class="n">max_order</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">corr_sum</span> <span class="o">=</span> <span class="n">r_mat</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r_mat</span><span class="o">**</span><span class="p">(</span><span class="n">max_order</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r_mat</span><span class="p">)</span>

        <span class="c1"># Truncation uncertainty</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">mu_sum</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">corr_sum</span>
        <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">ref_mat</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">ref</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">ref_mat</span>
        <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">R</span>

<div class="viewcode-block" id="PowerProcess.predictive"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.predictive">[docs]</a>    <span class="k">def</span> <span class="nf">predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Returns a posterior predictive distribution object.</span>

<span class="sd">        Predicts the value of the power series up to ``max_order`` at</span>
<span class="sd">        the input locations ``X``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : 2D array</span>
<span class="sd">            The new input points at which to predict the values of the</span>
<span class="sd">            coefficients or partial sums.</span>
<span class="sd">        corr : bool, optional</span>
<span class="sd">            Whether or not the distribution is correlated in the</span>
<span class="sd">            input space. For visualizing the mean and marginal variance, an</span>
<span class="sd">            uncorrelated conditional often suffices. Defaults to ``False``.</span>
<span class="sd">        max_order : int, optional</span>
<span class="sd">            The order at which to truncate the power series.</span>
<span class="sd">            Defaults to ``None``, which corresponds to an infinite sum.</span>
<span class="sd">        rescale : bool, optional</span>
<span class="sd">            Whether or not to rescale the truncated orders back to error bands</span>
<span class="sd">            on a partial sum. Defaults to ``True``.</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``, which uses the values passed to ``observe``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the correlation function.</span>
<span class="sd">            Defaults to the keywords passed to ``observe``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distribution object</span>
<span class="sd">            If ``corr is False`` then a ``scipy.stats.t`` distribution is</span>
<span class="sd">            returned, else a</span>
<span class="sd">            ``statsmodels.sandbox.distributions.mv_normal.MVT`` is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="k">if</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># Always find error from best prediction</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrated_conditional</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="n">max_order</span><span class="p">,</span>
                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_predictive</span><span class="p">(</span>
                <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="n">max_order</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">student_params</span><span class="p">(</span>
                <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MVT</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerProcess.predict"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Predicts the power series value and provides error bands.</span>

<span class="sd">        Gets the mean value of the predictive distribution and computes</span>
<span class="sd">        the degree of belief interval.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xnew : 2D array</span>
<span class="sd">            The new input points at which to predict the values of the</span>
<span class="sd">            coefficients or partial sums.</span>
<span class="sd">        dob : scalar or 1D array, optional</span>
<span class="sd">            The degree of belief intervals to compute, between 0 and 1.</span>
<span class="sd">        max_order : int, optional</span>
<span class="sd">            The order at which to truncate the power series.</span>
<span class="sd">            Defaults to ``None``, which corresponds to an infinite sum.</span>
<span class="sd">        rescale : bool, optional</span>
<span class="sd">            Whether or not to rescale the truncated orders back to error bands</span>
<span class="sd">            on a partial sum. Defaults to ``True``.</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``, which uses the values passed to ``observe``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the correlation function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1D array or tuple</span>
<span class="sd">            If ``dob is None``, then only the 1D array of predictions is</span>
<span class="sd">            returned. Otherwise, the predictions along with a</span>
<span class="sd">            :math:`2 \times N` (or :math:`len(dob) \times 2 \times N`) of</span>
<span class="sd">            degree of belief intervals is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictive</span><span class="p">(</span>
            <span class="n">Xnew</span><span class="o">=</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="n">max_order</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
            <span class="n">ignore_rm</span><span class="o">=</span><span class="n">ignore_rm</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="n">dob</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerProcess.evidence"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.evidence">[docs]</a>    <span class="k">def</span> <span class="nf">evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Computes the evidence, or marginal likelihood, of the partial sums</span>

<span class="sd">        Specifically, the evidence integrates out :math:`\beta` and</span>
<span class="sd">        :math:`\sigma^2` such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr({S_i} | \psi, r, S_{\mathrm{ref}})</span>
<span class="sd">            &amp; = \frac{pr(y | \psi)}{\prod_i |S_{\mathrm{ref}} r^i|} \\</span>
<span class="sd">            &amp; = \frac{1}{\prod_n |S_{\mathrm{ref}} r^n|}</span>
<span class="sd">                \frac{\Gamma(a)}{\Gamma(a_0)} \frac{b_0^{a_0}}{b^a}</span>
<span class="sd">                \sqrt{\frac{|V|}{|V_0|}} [(2\pi)^N |R|]^{-n/2}</span>

<span class="sd">        where subscript 0&#39;s denote prior values. If the priors on :math:`a_0`</span>
<span class="sd">        or :math:`V_0` are uninformative, then the evidence is undefined, but</span>
<span class="sd">        in this case the evidence is approximated by</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr({S_i} | \psi, r, S_{\mathrm{ref}})</span>
<span class="sd">            = \frac{1}{\prod_i |S_{\mathrm{ref}} r^i|}</span>
<span class="sd">              \frac{\Gamma(a) \sqrt{|V|}}{b^a} [(2\pi)^N |R|]^{-n/2}</span>

<span class="sd">        This is appropriate for model comparison since the factor due to priors</span>
<span class="sd">        is only a constant and hence cancels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log : bool, optional</span>
<span class="sd">            Whether to return the log of the evidence, which can be useful</span>
<span class="sd">            for numerical reasons.</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``, which uses the values passed to ``observe``.</span>
<span class="sd">        **corr_kwargs : optional</span>
<span class="sd">            Keyword arguments passed to the correlation function. Defaults</span>
<span class="sd">            to those passed to the ``observe`` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            The (log) evidence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>

        <span class="c1"># Compute evidence of coefficients</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PowerProcess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">evidence</span><span class="p">(</span>
            <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;leading_process&#39;</span><span class="p">):</span>
            <span class="n">ev</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leading_process</span><span class="o">.</span><span class="n">evidence</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Consider ratio and ref too</span>
        <span class="n">ev</span> <span class="o">-=</span> <span class="n">num_c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)))</span>
        <span class="n">ev</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ev</span></div>

<div class="viewcode-block" id="PowerProcess.posterior"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerProcess.posterior">[docs]</a>    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">logprior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the posterior pdf for arbitrary correlation or ratio variables</span>

<span class="sd">        Uses Bayes&#39; Theorem to compute</span>

<span class="sd">        .. math::</span>

<span class="sd">            pr(x | y, ...) \propto pr(y | x, ...) pr(x)</span>

<span class="sd">        for any correlation or ratio parameter :math:`x`. The evidence given</span>
<span class="sd">        :math:`x` and the other correlation and ratio parameters (...) is then</span>
<span class="sd">        used to compute the posterior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the variable passed to the correlation or ratio</span>
<span class="sd">            function for which to calculate the posterior. First checks</span>
<span class="sd">            ``corr_kwargs`` and if it is not found, then checks</span>
<span class="sd">            ``ratio_kwargs``.</span>
<span class="sd">        logprior : callable, optional</span>
<span class="sd">            The log prior to place on ``name``. Must accept ``**corr_kwargs``</span>
<span class="sd">            as arguments. Defaults to ``None``, which sets ``logprior`` to zero</span>
<span class="sd">        log : bool, optional</span>
<span class="sd">            Whether to return the log posterior. If ``False``, then the pdf</span>
<span class="sd">            will be approximately normalized using the trapezoid rule. Defaults</span>
<span class="sd">            to ``False``</span>
<span class="sd">        ratio_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function.</span>
<span class="sd">        **corr_kwargs :</span>
<span class="sd">            Keyword arguments passed to the correlation function. One of the</span>
<span class="sd">            arguments must match ``name`` and must be an array. Nothing will</span>
<span class="sd">            be inferred from the ``observe`` call here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The (log) posterior pdf for the ``name`` variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">corr_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PowerProcess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">posterior</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">logprior</span><span class="o">=</span><span class="n">logprior</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">log_pdf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">logprior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">logprior</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">ratio_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">ratio_kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evidence</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ratio_kwargs</span><span class="o">=</span><span class="n">ratio_kwargs</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">corr_kwargs</span><span class="p">)</span>

        <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="c1"># Integrate using trapezoid rule</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pdf</span><span class="o">/</span><span class="n">norm</span>
        <span class="k">return</span> <span class="n">log_pdf</span></div></div>

    <span class="c1"># def ratio_post(self, ratio_kwargs, logprior=None, **corr_kwargs):</span>
    <span class="c1">#     if not callable(logprior):</span>
    <span class="c1">#         raise ValueError(&#39;logprior must be callable&#39;)</span>

    <span class="c1">#     def ratio_ev(**kwargs):</span>
    <span class="c1">#         coeffs = self._recompute_coeffs(**kwargs)</span>
    <span class="c1">#         return self.evidence(log=True, y=coeffs, **corr_kwargs)</span>

    <span class="c1">#     vec_evidence = np.vectorize(self.ratio_ev)</span>
    <span class="c1">#     log_post = vec_evidence(**ratio_kwargs)</span>
    <span class="c1">#     if logprior is not None:</span>
    <span class="c1">#         log_post = log_post + logprior(**ratio_kwargs)</span>
    <span class="c1">#     log_post -= np.max(log_post)</span>
    <span class="c1">#     return np.exp(log_post)</span>


<div class="viewcode-block" id="PowerSeries"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerSeries">[docs]</a><span class="k">class</span> <span class="nc">PowerSeries</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">R</span><span class="sd">&quot;&quot;&quot;A power series with iid random variables as coefficients.</span>

<span class="sd">    Implements the following model</span>

<span class="sd">    .. math::</span>

<span class="sd">        S_k = S_{\mathrm{ref}} \sum_{n=0}^k c_n r^n</span>

<span class="sd">    where the :math:`c_n` are iid Gaussians and :math:`\sigma^2` has a</span>
<span class="sd">    conjugate prior</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_n | \sigma^2 &amp; \sim N(0, \sigma^2) \\</span>
<span class="sd">        \sigma^2 &amp; \sim IG(a, b)</span>

<span class="sd">    Conditioning on partial sums :math:`S_0`, :math:`\dots,` :math:`S_k`, allow</span>
<span class="sd">    one to estimate the full summation and obtain posteriors for the</span>
<span class="sd">    parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">=</span> <span class="n">scale</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span>

<div class="viewcode-block" id="PowerSeries.observe"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerSeries.observe">[docs]</a>    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">rm_orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;Observe the partial sums of the series and update parameters.</span>

<span class="sd">        The partial sums are observed and converted to coefficients</span>
<span class="sd">        using the given ``ratio`` and ``ref``. Posterior distributions for the</span>
<span class="sd">        mean and variance parameters can then be calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        partials : (n,N) array</span>
<span class="sd">            The :math:`n` lowest known partial sums, each with :math:`N` points</span>
<span class="sd">            observed along each partial sum.</span>
<span class="sd">        ratio : callable, scalar, or length (N,) 1D array</span>
<span class="sd">            The value of the ratio that scales each order in the power</span>
<span class="sd">            series with increasing powers. If callable, it must accept ``X``</span>
<span class="sd">            as its first argument and can optionally accept ``**ratio_kwargs``.</span>
<span class="sd">        ref : callable, scalar, or length (N,) 1D array</span>
<span class="sd">            The overall scale of the power series. If callable, it must</span>
<span class="sd">            accept ``X`` as its first argument. The default value is 1.</span>
<span class="sd">        orders : (n,) array</span>
<span class="sd">            The orders of the given partial sums. If ``None``, it is assumed</span>
<span class="sd">            that all orders from 0 to math:`n` are given: ``[0, 1, ..., n]``.</span>
<span class="sd">        rm_orders : 1D array</span>
<span class="sd">            The orders of partial sums, if any, to ignore during conditioning.</span>
<span class="sd">            This could be useful if it is known that some coefficients will</span>
<span class="sd">            not behave as iid Gaussian.</span>
<span class="sd">        X : (N,d) array, optional</span>
<span class="sd">            The :math`N` input locations where the partial sums are observed.</span>
<span class="sd">            Columns correspond to the dimensionality of the input space. If 1D,</span>
<span class="sd">            ``X`` must be an :math:`N \times 1` column vector.</span>
<span class="sd">        **ratio_kwargs : optional</span>
<span class="sd">            Additional keyword arguments passed to the ratio function. Defaults</span>
<span class="sd">            to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span> <span class="o">=</span> <span class="n">ratio_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span> <span class="o">=</span> <span class="n">orders</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partials</span> <span class="o">=</span> <span class="n">partials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_function</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
        <span class="c1"># self.ref = self._domain_function(ref)</span>
        <span class="c1"># if callable(ratio):</span>
        <span class="c1">#     self.ratio = ratio(X, **ratio_kwargs)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.ratio = ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_function</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>

        <span class="k">if</span> <span class="n">rm_orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rm_orders</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">partials</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">(</span>
            <span class="n">partials</span><span class="o">=</span><span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="n">orders</span><span class="p">,</span>
            <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="c1"># Get max order</span>
        <span class="n">max_order_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">orders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">max_order_arg</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_partial</span> <span class="o">=</span> <span class="n">partials</span><span class="p">[</span><span class="n">max_order_arg</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="n">rm_orders</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orders</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordersvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rm_orders</span> <span class="o">=</span> <span class="n">rm_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_domain_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">isNumber</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">*</span><span class="n">obj</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">isNumber</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">elif</span> <span class="n">isNumber</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dom_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">obj</span> <span class="o">*</span> <span class="n">vec</span>
            <span class="k">return</span> <span class="n">dom_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> must be a number or function&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_recompute_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ratio_kwargs</span> <span class="ow">and</span> <span class="n">ratio_kwargs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span><span class="p">:</span>
            <span class="c1"># print(&#39;recomputing...&#39;)</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">(</span>
                <span class="n">partials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partials</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
                <span class="n">ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_orders</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span>

<div class="viewcode-block" id="PowerSeries.shape"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerSeries.shape">[docs]</a>    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The shape parameter :math:`a` of the inverse gamma distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">num_c</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span> <span class="o">+</span> <span class="n">num_c</span> <span class="o">/</span> <span class="mf">2.0</span></div>

<div class="viewcode-block" id="PowerSeries.scale"><a class="viewcode-back" href="../../api/models.html#buqeyemodel.models.PowerSeries.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="sa">R</span><span class="sd">&quot;&quot;&quot;The scale parameter :math:`b` of the inverse gamma distribution.</span>

<span class="sd">        [description]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **ratio_kwargs : {[type]}</span>
<span class="sd">            [description]</span>
<span class="sd">        combine : {bool}, optional</span>
<span class="sd">            [description] (the default is False, which [default_description])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [type]</span>
<span class="sd">            [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">csq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">+</span> <span class="n">csq</span><span class="o">/</span><span class="mf">2.0</span></div>

    <span class="k">def</span> <span class="nf">predictive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ratio_kwargs</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shape</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scale</span> <span class="o">/</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Geometric sum of ratio orders</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">sd</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r2</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="n">k</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r2</span><span class="p">))</span>

        <span class="c1"># Create error bands around best prediction</span>
        <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="n">sd</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_partial</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictive</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dob</span><span class="o">=</span><span class="n">dob</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ratio_kwargs</span><span class="p">:</span>
            <span class="n">ratio_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio_kwargs</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>
        <span class="n">num_c</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Compute evidence of coefficients elementwise</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">num_c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">ev</span> <span class="o">+=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">shape</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_0</span>
            <span class="n">scale_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_0</span>
            <span class="n">ev</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">shape_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">shape_0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale_0</span><span class="p">)</span>

        <span class="c1"># Consider ratio and ref too</span>
        <span class="n">ev</span> <span class="o">-=</span> <span class="n">num_c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">ev</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ev</span>

    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">logprior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">val</span><span class="p">)}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evidence</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">,</span> <span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="n">log_pdf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">logprior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">logprior</span><span class="p">(</span><span class="o">**</span><span class="n">ratio_kwargs</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">ratio_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">log_pdf</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">log_pdf</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
            <span class="c1"># Integrate using trapezoid rule</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pdf</span><span class="o">/</span><span class="n">norm</span>
        <span class="k">return</span> <span class="n">log_pdf</span>

    <span class="k">def</span> <span class="nf">credible_diagnostic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictive</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dobs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">indicator</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="p">)</span>  <span class="c1"># 1 if within, 0 if out</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># The diagnostic</span></div>
</pre></div>

          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">buqeyemodel 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Jordan Melendez. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>